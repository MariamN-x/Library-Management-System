
import java.util.ArrayList;
import java.util.Date;
import java.io.Serializable;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javafx.scene.control.Alert;

class Borrowing implements Serializable {
    private static final long serialVersionUID = 7658793135987417738L;
    
    public static List<Borrowing> borrowingsList = new ArrayList<>();
    public static List<Book>borrowedBooks=new ArrayList<>();
    private static HashMap<String, Integer> borrowCount = new HashMap<>();// isbn w count
    private static HashMap<String, Double> bookRevenueMap = new HashMap<>();// isbn w price
    private static HashMap<User, Double> userRevenueMap = new HashMap<>(); // borrower w price
    private User user;
    private Date startDate;
    private Date endDate;
    private double payment;
    private double rating;
    Calendar calendar;    // to set the end date to be after 2 weeks of start date
    
    public Borrowing(){}
    public Borrowing(User user) {
        if (user instanceof Borrower || user instanceof Librarian) {
            this.user = user;
        } else {
            throw new IllegalArgumentException("Invalid user type for borrowing");
        }
    }
    public User getUser() {
        return user;
    }
    public void setUser(User user) {
        this.user = user;
    }
    public Date getStartDate() {
        return startDate;
    }

    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }

    public Date getEndDate(Date start) {
        calendar = Calendar.getInstance();
        calendar.setTime(start);
        calendar.add(Calendar.WEEK_OF_YEAR, 2); // after 2 weeks of borrowing
        endDate = calendar.getTime();
        return endDate;
    }

    public double getPayment() {
        return payment;
    }

    public void setPayment(double payment) {
        this.payment = payment;
    }

    public double getRating() {
        return rating;
    }

    public void setRating(double rating) {
        this.rating = rating;
    }
    
    public static void setBorrowCount() {
        borrowCount.clear();
        if(borrowedBooks.isEmpty())
        {
          Borrowing.borrowedBooks=Files.readObjectsFromFile("borrowedBooks.bin"); 
        }
        for (Book b : borrowedBooks) {
            String isbn = b.getISBN();
            if (borrowCount.containsKey(isbn)) {
                int count = borrowCount.get(isbn);
                borrowCount.put(isbn, count + 1);
            } else {
                borrowCount.put(isbn, 1);
            }
        }
    }
  
 public static void setBookRevenueMap() {
        bookRevenueMap.clear();
        if (borrowedBooks.isEmpty()) {
            Borrowing.borrowedBooks = Files.readObjectsFromFile("borrowedBooks.bin");
        }
        for (Book b : borrowedBooks) {
            String isbn = b.getISBN();
            double bookPrice = b.getPrice();
            if (bookRevenueMap.containsKey(isbn)) {
                double currentRevenue = bookRevenueMap.get(isbn);
                bookRevenueMap.put(isbn, currentRevenue + bookPrice);
            } else {
                bookRevenueMap.put(isbn, bookPrice);
            }
        }
    }

public static void setBorrowerRevenueMap() {
        userRevenueMap.clear();
        for (Borrowing borrowing : borrowingsList) {
            User user = borrowing.getUser();
            Double revenue = userRevenueMap.get(user);

            if (revenue == null) {
                revenue = 0.0;
            }

            for (Book book : Borrowing.borrowedBooks) {
                double bookPrice = book.getPrice();
                revenue += bookPrice;
            }

            userRevenueMap.put(user, revenue);
        }
}

 public double calculateRevenue() {
        double revenue = 0.0;
        for (Book book : borrowedBooks) {
            double bookPrice = book.getPrice();
            revenue += bookPrice;
        }
        return revenue;
    }
    
//public void createBorrowing(Date startDate, Borrower borrower, List<Book> borrowedBooks, double totalPrice) {
//    Borrowing newBorrowing = new Borrowing( borrower);
//    newBorrowing.startDate = startDate;
//    newBorrowing.endDate = newBorrowing.getEndDate(startDate);
//    setBorrowCount(borrowedBooks);
//    //check quntity for each book
//    for (Book book : borrowedBooks) {
//        if (book.getQuantity() > 0) {
//            book.setQuantity(book.getQuantity() - 1);
//            totalPrice = this.totalBorrowingPrice(borrowedBooks);
//            newBorrowing.payment = totalPrice;        
//            //Dialogs.showAlert("The book " + book.getTitle() + " added to your borrowings list.", Alert.AlertType.INFORMATION);
//            //Dialogs.showAlert("Borrowing successful!\nThe End Date of your borrowing will be in:-\n " +newBorrowing.getEndDate(startDate),Alert.AlertType.INFORMATION);   
//        } else {
//            //Dialogs.showAlert("Book not available for borrowing: " + book.getTitle(), Alert.AlertType.WARNING);
//        }
//    }
//    Borrowing.borrowingsList.add(newBorrowing);
//} 
 public void createBorrowing(Date startDate, User user, List<Book> borrowedBooks, double totalPrice) {
    Borrowing newBorrowing = new Borrowing(user);
    newBorrowing.startDate = startDate;
    newBorrowing.endDate = newBorrowing.getEndDate(startDate);

    for (Book book : borrowedBooks) {
        if (book.getQuantity() > 0) {
            book.setQuantity(book.getQuantity() - 1);
            totalPrice = this.totalBorrowingPrice(Borrowing.borrowedBooks);
            newBorrowing.payment = totalPrice;
            Borrowing.borrowedBooks.add(book);
        } else {
            return; // Stop creating new borrowings if a book is not available(Quantity= 0)
        }
    }

    // Update borrowed books list for the user
    if (user instanceof Borrower) {
        ((Borrower) user).setBorrowedBooksperBorrower(Borrowing.borrowedBooks);
        ((Borrower) user).getBorrowingsPerBorrower().add(newBorrowing);
    } else if (user instanceof Librarian) {
        ((Librarian) user).setBorrowedBooksperLibrarian(Borrowing.borrowedBooks);
        ((Librarian) user).getBorrowingsPerLibrarian().add(newBorrowing);
    }

    borrowingsList.add(newBorrowing);
    setBorrowCount(); // Update the borrow count for all borrowed books
    setBookRevenueMap();
    setBorrowerRevenueMap();
}

 
//public void editBorrowing(String attributeName, Object newValue) {
//        for (Borrowing borrowing : borrowingsList) {
//                switch (attributeName.toLowerCase()) {
//                    case "startdate":
//                        borrowing.startDate = (Date) newValue;
//                        break;
//                    case "enddate":
//                        borrowing.endDate = (Date) newValue;
//                        break;
//                    case "borrowers":
//                        borrowing.user = (Borrower)newValue;
//                        break;
//                    case "books":
//                        Borrowing.borrowedBooks = (ArrayList<Book>) newValue;
//                        break;
//                    case "payment":
//                        borrowing.payment = (Double) newValue;
//                        break;
//                    default:
//                        System.out.println("Invalid attribute name.");
//                        return;
//                }
//                System.out.println("Borrowing record updated.");
//                break;
//        }
//}

//public void cancelBorrowingByAttributes(Borrower borrower, ArrayList<Book> borrowedBooks) {    
//    for (int i = 0; i < borrowingsList.size(); i++) {
//        Borrowing borrowing = borrowingsList.get(i);
//        if (borrowing.borrower.getUserName().equals(borrower.getUserName())) {
//            borrowingsList.remove(i);
//            System.out.println("Borrowing record canceled.");
//            break;
//        }
//    }        
//}

public static List<String> getAllBorrowingDetails() {
    List<String> detailsList = new ArrayList<>();

    if (borrowingsList.isEmpty()) {
        detailsList.add("No borrowings available.");
        return detailsList;
    }

    for (Borrowing borrowing : borrowingsList) {
        detailsList.add("Borrowing Details:");
        detailsList.add("User: " + borrowing.getUser().getUserName());
        detailsList.add("Start Date: " + borrowing.getStartDate());
        detailsList.add("End Date: " + borrowing.getEndDate(borrowing.getStartDate()));
        detailsList.add("Payment: " + borrowing.getPayment());
        detailsList.add("Rating: " + borrowing.getRating());
        if(borrowedBooks.isEmpty()){
        Borrowing.borrowedBooks=Files.readObjectsFromFile("borrowedBooks.bin"); }
        detailsList.add("Borrowed Books:");
        for (Book book : borrowedBooks) {
            detailsList.add("- ISBN: " + book.getISBN() + ", Title: " + book.getTitle() + ", Price: " + book.getPrice());
        }

        detailsList.add("------------------------------");
    }

    return detailsList;
}

public double totalBorrowingPrice(List<Book>borrowed)
{
    double price=0.0;
    for(Book bor:borrowed)
       price+=bor.getPrice();
    return price;
}
public static double totalBorrowingRevInPeriod(String startDateStr, String endDateStr) {
    try {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);

        double totalRevenue = 0.0;

        for (Borrowing borrowing : borrowingsList) {
            Date borrowingStartDate = borrowing.getStartDate();
            Date borrowingEndDate = borrowing.getEndDate(borrowingStartDate);

            if (startDate.before(borrowingEndDate) && endDate.after(borrowingStartDate)) {
                totalRevenue += borrowing.calculateRevenue();
            }
        }

        return totalRevenue;
    } catch (ParseException e) {
        Dialogs.showAlert("Date format is incorrect", Alert.AlertType.ERROR);
        return 0.0;
    }
}

public static double averageBorrowingRevenueInPeriod(String startDateStr, String endDateStr) {
    try {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);

        double totalRevenue = 0.0;
        int borrowingCount = 0;

        for (Borrowing borrowing : borrowingsList) {
            Date borrowingStartDate = borrowing.getStartDate();
            Date borrowingEndDate = borrowing.getEndDate(borrowingStartDate);

            if (startDate.before(borrowingEndDate) && endDate.after(borrowingStartDate)) {
                totalRevenue += borrowing.calculateRevenue();
                borrowingCount++;
            }
        }

        if (borrowingCount > 0) {
            return totalRevenue / borrowingCount;
        } else {
            return 0.0; // To avoid division by zero
        }
    } catch (ParseException e) {
        Dialogs.showAlert("Date format is incorrect", Alert.AlertType.ERROR);
        return 0.0;
    }
}


public static int NoOfBorrowsInPeriod(String startDateStr, String endDateStr) {
    try {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);

        int count = 0;
        for (Borrowing borrowing : borrowingsList) {
            Date borrowingStartDate = borrowing.getStartDate();
            Date borrowingEndDate = borrowing.getEndDate(borrowingStartDate);

            if (startDate.before(borrowingEndDate) && endDate.after(borrowingStartDate)) {
                count++;
            }
        }
        return count;
    } catch (ParseException e) {
        Dialogs.showAlert("Date format is incorrect", Alert.AlertType.ERROR);
        return 0;
    }
}
//****make it return list<Book> in UML*****//
public static List<String> mostBorrowedBooksInPeriod(String startDateStr, String endDateStr) {
    List<Book> books = Files.readObjectsFromFile("book.bin");
    List<String> result = new ArrayList<>();

    if (books == null || books.isEmpty()) {
        System.out.println("No books available.");
        return Collections.emptyList();
    }   
    // Initialize borrowCount map
    Borrowing.setBorrowCount();
    try {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);

        int maxCount = 0;

        for (Borrowing borrowing : borrowingsList) {
            Date borrowingStartDate = borrowing.getStartDate();
            Date borrowingEndDate = borrowing.getEndDate(borrowingStartDate);

            if (startDate.before(borrowingEndDate) && endDate.after(borrowingStartDate)) {
                maxCount = Collections.max(borrowCount.values());
            }
        }

        // convert list of book to list of string just for showListDialog(List<String>)
        for (Map.Entry<String, Integer> entry : borrowCount.entrySet()) {
            if (entry.getValue() == maxCount) {
                Book foundBook = Book.findBookByISBN(books, entry.getKey());
                if (foundBook != null) {
                    result.add(foundBook.toString());
                } else {
                    System.out.println("Cannot find book with ISBN: " + entry.getKey());
                }
            }
        }

        return result;
    } catch (ParseException e) {
        Dialogs.showAlert("Date format is incorrect", Alert.AlertType.ERROR);
        return null;
    }
}

public static List<String> mostRevenueBooksInPeriod(String startDateStr, String endDateStr) {
    List<Book> books = Files.readObjectsFromFile("book.bin");
    List<String> result = new ArrayList<>();
    if (books == null || books.isEmpty()) {
        System.out.println("No books available.");
        return Collections.emptyList();
    }
    try {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        setBookRevenueMap();
        for (Borrowing borrowing : borrowingsList) {
            Date borrowingStartDate = borrowing.getStartDate();
            Date borrowingEndDate = borrowing.getEndDate(borrowingStartDate);

            if (startDate.before(borrowingEndDate) && endDate.after(borrowingStartDate)) {
                List<Book> borrowed = Borrowing.borrowedBooks;

                for (Book book : borrowed) {
                    double currentRevenue = bookRevenueMap.getOrDefault(book.getISBN(), 0.0);
                    currentRevenue += book.getPrice();
                    bookRevenueMap.put(book.getISBN(), currentRevenue);
                }
            }
        }

        if (bookRevenueMap.isEmpty()) {
            System.out.println("No revenue recorded for the specified period.");
            return Collections.emptyList();
        }

        // Find the book with the maximum revenue
        String mostRevenueBookISBN = Collections.max(bookRevenueMap.entrySet(), Map.Entry.comparingByValue()).getKey();
        Book mostRevenueBook = Book.findBookByISBN(books, mostRevenueBookISBN);

        if (mostRevenueBook != null) {
            double maxRevenue = bookRevenueMap.get(mostRevenueBookISBN);
            result.add("Most Revenue Book: " + mostRevenueBook.toString());
            result.add("Revenue: " + maxRevenue);
        } else {
            System.out.println("Cannot find the most revenue book.");
        }

        return result;
    } catch (ParseException e) {
        Dialogs.showAlert("Date format is incorrect", Alert.AlertType.ERROR);
        return Collections.emptyList();
    }
}

// //***** make it return Borrower in the UML****
//   public static List<String> borrowerWithMaxRevenue() {
//    setBorrowerRevenueMap();
//    List<Borrower> maxRevenueBorrowers = new ArrayList<>();
//    double maxRevenue = Double.MIN_VALUE;
//
//    for (Borrowing borrowing : borrowingsList) {
//        Borrower borrower = borrowing.getBorrower();
//        Double revenue = borrowerRevenueMap.get(borrower);
//        if (revenue == null) {
//            revenue = 0.0;
//        }
//
//        revenue += borrowing.calculateRevenue();
//        borrowerRevenueMap.put(borrower, revenue);
//
//        if (revenue > maxRevenue) {
//            maxRevenue = revenue;
//            maxRevenueBorrowers.clear(); // Clear the list if a new maximum is found
//            maxRevenueBorrowers.add(borrower);
//        } else if (revenue == maxRevenue) {
//            maxRevenueBorrowers.add(borrower);
//        }
//    }
//
//    List<String> result = new ArrayList<>();
//    for (Borrower borrower : maxRevenueBorrowers) {
//        result.add(borrower.toString());
//    }
//
//    return result;
//}
// 
public static List<User> getMaxUserBorrowings(User obj) {
    List<User> maxUsersBorrowings = new ArrayList<>();
    int maxBorrowingsCount = 0;

    if (obj instanceof Borrower) {
        for (User user : User.users) {
            if (user instanceof Borrower) {
                List<Book> userBorrowings = ((Borrower) user).getBorrowedBooksperBorrower();
                int borrowingsCount = Collections.frequency(userBorrowings, obj);

                if (borrowingsCount > maxBorrowingsCount) {
                    maxBorrowingsCount = borrowingsCount;
                    maxUsersBorrowings.clear();
                    maxUsersBorrowings.add(user);
                } else if (borrowingsCount == maxBorrowingsCount) {
                    maxUsersBorrowings.add(user);
                }
            }
        }
    } else if (obj instanceof Librarian) {
        for (User user : User.users) {
            if (user instanceof Librarian) {
                List<Book> userBorrowings = ((Librarian) user).getBorrowedBooksperLibrarian();
                int borrowingsCount = Collections.frequency(userBorrowings, obj);

                if (borrowingsCount > maxBorrowingsCount) {
                    maxBorrowingsCount = borrowingsCount;
                    maxUsersBorrowings.clear();
                    maxUsersBorrowings.add(user);
                } else if (borrowingsCount == maxBorrowingsCount) {
                    maxUsersBorrowings.add(user);
                }
            }
        }
    }

    return maxUsersBorrowings;
}






}
